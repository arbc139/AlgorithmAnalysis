package algoHW2;

import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;

import lineSegment.*;
import dy.DYFile;
import dy.DYConsole;

public class AlgoHW2 {
	static DYFile file;	// file object
	
	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		file = new DYFile(2);				// homework no.2!
		DYConsole.consoleTurnOn = false;	// turn on/off console mode!
		
		findCrossingPoint();				// let's find the crossing point~
		
		file.close();
	}
	
	/*
	 * findCrossingPoint function
	 * - to find crossing point in the input case
	 */
	static void findCrossingPoint() throws Exception {
		String numberStr = file.fin.readLine();
		if(numberStr==null) throw new Exception();	// no input --> exception
		
		// parsing number of tree.
		int numberOfTestCase = Integer.parseInt(numberStr);
		
		// loop with number of test case
		for(int i=0; i<numberOfTestCase; i++) {
			file.fin.readLine(); // remove "\n"
			int numberOfPoint = Integer.parseInt(file.fin.readLine());
			ArrayList<Point> points = new ArrayList<Point>();			// array which contain points
			
			// parsing input, make point objects, and fill out array with those point objects
			for(int j=0; j<numberOfPoint; j++) {
				String pointInputStr = file.fin.readLine();
				DYConsole.println("(" + i + ")::" + pointInputStr);
				makePoint(pointInputStr, points);
				DYConsole.println("(" + i + ")::" + "x" + points.get(j).getX() + ", y" + points.get(j).getY());
			}
			
			ArrayList<LineSegment> lineSegments = new ArrayList<LineSegment>();
			findLineSegments(points, lineSegments);
			
			ArrayList<Point> foundPoints = new ArrayList<Point>();
			for(int j=0; j<points.size(); j++) {
				DYConsole.println("points[" + points.get(j).getX() + "," + points.get(j).getY() + "] line: " + points.get(j).showAssignedLineSegment());
				if(points.get(j).getSegmentList().size() >= 2) foundPoints.add(points.get(j));
			}
			
			// sorting to lexicographic
			Collections.sort(foundPoints, new Point.lexicographicCompare());
			file.fout.println(foundPoints.size());
			for(int j=0; j<foundPoints.size(); j++) {
				DYConsole.println("sorted points[" + foundPoints.get(j).getX() + "," + foundPoints.get(j).getY() + "] line: " + foundPoints.get(j).showAssignedLineSegment());
				file.fout.println(foundPoints.get(j).getX() + " " + foundPoints.get(j).getY());
			}
			file.fout.println();
		}
	}
	
	static void makePoint(String pointInputStr, ArrayList<Point> points) {
		StringTokenizer st = new StringTokenizer(pointInputStr);		// split lines
		int x = Integer.parseInt(st.nextToken());	int y = Integer.parseInt(st.nextToken());
		points.add(new Point(x,y));
	}
	
	static void findLineSegments(ArrayList<Point> points, ArrayList<LineSegment> lineSegments) throws Exception {
		if(points.size() <= 2) {
			// print out fail to find
			return;
		}
		// O(n^3)
		for(int i=0; i<points.size(); i++) {
			for(int j=i+1; j<points.size(); j++) {
				if(points.get(i).isHavingSameLineSegment(points.get(j))) continue;
				int lineIndex = lineSegments.size();
				LineSegment line = new LineSegment(points.get(i), points.get(j));		// find line segment using point[i], point[j]

				Boolean firstTime = true;
				for(int k=j+1; k<points.size(); k++) {
					if(line.isOnLineSegment(points.get(k))) {
						if(firstTime) {
							line.addPoint(points.get(k));
							line.setPointsLineIndex(lineIndex);
							lineSegments.add(line);
							firstTime = false;
						}
						else {
							points.get(k).addSegmentIndex(lineIndex);
							line.addPoint(points.get(k));
						}
					}
				}
			}
		}
		
		
	}

}
